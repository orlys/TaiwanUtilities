<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Text.Json" #>
<#@ assembly name="System.Memory" #>
<#@ assembly name="System.Net.Http" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.Json" #>
<#@ import namespace="System.Threading.Tasks" #>
<#@ import namespace="System.Net.Http" #>
<#@ import namespace="System.Text.Json.Serialization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>

<#@ output extension=".g.cs" #>
<#
    //var sourceUrl = "https://data.ntpc.gov.tw/api/datasets/308dcd75-6434-45bc-a95f-584da4fed251/json?page=0&size=100000";
    var sourceUrl = "https://raw.githubusercontent.com/ruyut/TaiwanCalendar/refs/heads/master/data/{0}.json";
    var downloader = new Downloader(sourceUrl);
    var holidays = downloader.DownloadHolidays();
    var builder = new RocDateTimeHolidayCodeBuilder(sourceUrl);
    if (holidays.Any()) {
        builder.AddHolidays(holidays);
    } else {
        Error("Unable to retrieve holiday data");
    }
#><#= builder.Build() #>
<#+
internal class DateInfo
{
    [JsonPropertyName("date")]
    public string Date { get; set; }

    [JsonPropertyName("isHoliday")]
    public bool IsHoliday { get; set; }

    public override int GetHashCode()
    {
        return Date?.GetHashCode() ?? 0;
    }

    public override bool Equals(object obj)
    {
        return obj is DateInfo di ? GetHashCode() == di.GetHashCode() : false;
    }
}
[DebuggerDisplay("{ToString(),nq}")]
internal class RocDateTimeHolidayCodeBuilder
{
    private readonly object _lockObject;
    private readonly StringBuilder _codeBuilder;
    
    public override string ToString()
    {
        return _codeBuilder.ToString();
    }

    public RocDateTimeHolidayCodeBuilder(string sourceUrl)
    {
        var supportedFrom = 2017;
        var supportedTo = DateTime.Today.AddYears(+1).AddHours(+8).Year;
        _lockObject = new object();
        _codeBuilder = new StringBuilder(
$@"// <auto-generated>
// This code was generated by Text Templating Transformation Toolkit.
// Changes to this file may be overwritten if the code is regenerated.
// </auto-generated>

namespace TaiwanUtilities;

using System;
using System.Collections.Concurrent;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;

partial struct RocDateTime
{{

    private sealed class DateInfo
    {{
        [JsonPropertyName(""date"")]
        public string Date {{ get; set; }}

        [JsonPropertyName(""isHoliday"")]
        public bool IsHoliday {{ get; set; }}

        public override int GetHashCode()
        {{
            return Date?.GetHashCode() ?? 0;
        }}

        public override bool Equals(object obj)
        {{
            return obj is DateInfo di ? GetHashCode() == di.GetHashCode() : false;
        }}
    }}

    private sealed class Downloader {{
        public HashSet<DateInfo> DownloadHolidays(int year) 
        {{ 
            try {{
                return DownloadHolidaysAsync(year)
                    .GetAwaiter()
                    .GetResult();
            }}
            catch (Exception ex) {{
                Debug.WriteLine($""Error downloading holidays: {{ex.Message}}"");
                return new HashSet<DateInfo>();
            }}
        }}

        public async Task<HashSet<DateInfo>> DownloadHolidaysAsync(int year)
        {{
            var holidays = new HashSet<DateInfo>();
            using var client = new HttpClient();

            try
            {{
            
                var url = string.Format(""{sourceUrl}"", year);
                var response = await client.GetAsync(url);

                if (!response.IsSuccessStatusCode)
                {{
                    Debug.WriteLine($""Failed to download data for {{year}}: {{response.StatusCode}}"");
                    return holidays;
                }}

                var jsonString = await response.Content.ReadAsStringAsync();
                var jsonSerializerOptions = new JsonSerializerOptions
                {{
                    PropertyNameCaseInsensitive = true
                }};
                var yearHolidays = JsonSerializer.Deserialize<List<DateInfo>>(jsonString, jsonSerializerOptions);
                
                if (yearHolidays != null)
                {{
                    foreach (var item in yearHolidays.Where(h => h.IsHoliday))
                    {{
                        holidays.Add(item);
                    }}
                }}
            }}
            catch (Exception ex)
            {{
                Debug.WriteLine($""Error processing {{year}}: {{ex.Message}}"");
            }}

            if (holidays.Count == 0)
            {{
                Debug.WriteLine(""No holiday data was downloaded"");
            }}
            return holidays;
        }}
    }}

    /// <summary>
    /// 判斷是否為法定假日
    /// </summary>
    /// <remarks>僅支援民國 {(supportedFrom - 1911)} 年到民國 {(supportedTo - 1911)} 年的法定假日，行政院人事行政總處每年年中才會公布隔年的辦公日曆表，
    /// 此屬性的目前使用 <see href=""https://github.com/ruyut/TaiwanCalendar""/> 作為資料來源
    /// </remarks>
    public bool IsHoliday
    {{
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {{
            var dateTime = GetRawValue().DateTime;
            var year = dateTime.Year;
            if (year < {supportedFrom})
            {{
                return false;
            }}

            if (year < {supportedTo})
            {{
                return s_holidays.Contains(dateTime);
            }}

            return s_cache.GetOrAdd(year, (y) => s_downloader.Value.DownloadHolidays(y).Select(x => ParseToDateTime(x.Date)).ToHashSet()).Contains(dateTime);
        }}
    }}


    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static readonly Lazy<Downloader> s_downloader = new Lazy<Downloader>(() => new Downloader());

    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static readonly ConcurrentDictionary<int, ISet<DateTime>> s_cache = new ConcurrentDictionary<int, ISet<DateTime>>();

    private static DateTime ParseToDateTime(string s)
    {{
        return DateTime.ParseExact(s, ""yyyyMMdd"", null);
    }}

    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static readonly ISet<DateTime> s_holidays = FrozenSet.ToFrozenSet(new []{{
");
    }

    public RocDateTimeHolidayCodeBuilder AddHolidays(IEnumerable<DateInfo> dateInfos)
    {
        if (dateInfos == null) return this;
        
        lock (_lockObject)
        {
            foreach (var dateInfo in dateInfos.Where(d => d.IsHoliday))
            {
                AddHolidayCore(dateInfo);
            }
        }
        return this;
    }

    private void AddHolidayCore(DateInfo dateInfo)
    {
        if (string.IsNullOrEmpty(dateInfo?.Date)) return;
        
        _codeBuilder
            .Append("        ")
            .AppendFormat("ParseToDateTime(\"{0}\")", dateInfo.Date)
            .AppendLine(",");
    }

    public string Build()
    {
        return _codeBuilder
            .AppendLine(
@"    });
}").ToString();
    }
}

internal class Downloader {

    private readonly string _sourceUrl;
    public Downloader(string sourceUrl)
    {
        _sourceUrl = sourceUrl;
    }

    public HashSet<DateInfo> DownloadHolidays() 
    { 
        try {
            return DownloadHolidaysAsync()
                .GetAwaiter()
                .GetResult();
        }
        catch (Exception ex) {
            Debug.WriteLine($"Error downloading holidays: {ex.Message}");
            return new HashSet<DateInfo>();
        }
    }

    public async Task<HashSet<DateInfo>> DownloadHolidaysAsync()
    {
        var holidays = new HashSet<DateInfo>();
        using var client = new HttpClient();

        var currentYear = DateTime.Now.Year;
        for (int year = 2017; year <= currentYear + 1; year++)
        {
            try
            {
            
                var url = string.Format(_sourceUrl, year);
                var response = await client.GetAsync(url);

                if (!response.IsSuccessStatusCode)
                {
                    Debug.WriteLine($"Failed to download data for {year}: {response.StatusCode}");
                    continue;
                }

                var jsonString = await response.Content.ReadAsStringAsync();
                var jsonSerializerOptions = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };
                var yearHolidays = JsonSerializer.Deserialize<List<DateInfo>>(jsonString, jsonSerializerOptions);
                
                if (yearHolidays != null)
                {
                    foreach (var item in yearHolidays.Where(h => h.IsHoliday))
                    {
                        holidays.Add(item);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error processing {year}: {ex.Message}");
            }
        }

        if (holidays.Count == 0)
        {
            Debug.WriteLine("No holiday data was downloaded");
        }
        return holidays;
    }
}
#>